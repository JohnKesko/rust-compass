{
    "category": "Traits and Types",
    "rules": [
        {
            "id": "impl-trait",
            "pattern": "impl\\s+\\w+\\s*\\{|impl\\s+\\w+\\s+for",
            "title": "Implementing Traits",
            "rustTerm": "impl blocks",
            "explanation": "Use `impl` to add methods to types or implement traits. `impl Trait for Type` implements a trait.",
            "example": "impl Display for MyType {\n    fn fmt(&self, f: &mut Formatter) -> fmt::Result {\n        write!(f, \"...\")\n    }\n}",
            "deepExplanation": "## impl Blocks\n\n### Inherent Implementation\n```rust\nstruct Counter {\n    value: u32,\n}\n\nimpl Counter {\n    // Associated function (no self)\n    fn new() -> Self {\n        Counter { value: 0 }\n    }\n    \n    // Method (has self)\n    fn increment(&mut self) {\n        self.value += 1;\n    }\n    \n    fn get(&self) -> u32 {\n        self.value\n    }\n}\n```\n\n### Trait Implementation\n```rust\nimpl Display for Counter {\n    fn fmt(&self, f: &mut Formatter) -> fmt::Result {\n        write!(f, \"Counter({})\", self.value)\n    }\n}\n```\n\n### self Variants\n| Signature | Meaning |\n|-----------|--------|\n| `&self` | Borrow immutably |\n| `&mut self` | Borrow mutably |\n| `self` | Take ownership |\n| `Self` | The implementing type |\n\n### Multiple impl Blocks\n```rust\n// You can have multiple impl blocks\nimpl Counter {\n    fn new() -> Self { ... }\n}\n\nimpl Counter {\n    fn increment(&mut self) { ... }\n}\n```",
            "confidence": 0.4,
            "contexts": [
                "general"
            ]
        },
        {
            "id": "derive-macro",
            "pattern": "#\\[derive\\(",
            "title": "Derive Macro",
            "rustTerm": "#[derive(...)]",
            "explanation": "Derive automatically implements common traits. Most types should derive Debug at minimum.",
            "example": "#[derive(Debug, Clone, PartialEq)]\nstruct Point { x: i32, y: i32 }",
            "deepExplanation": "## Derive Macro\n\nAutomatically implement common traits.\n\n### Common Derives\n```rust\n#[derive(\n    Debug,      // {:?} formatting\n    Clone,      // .clone() method\n    Copy,       // Implicit copy (small types only)\n    PartialEq,  // == comparison\n    Eq,         // Total equality (requires PartialEq)\n    Hash,       // Can be HashMap key (requires Eq)\n    Default,    // Default::default()\n    PartialOrd, // <, >, <=, >= comparison\n    Ord,        // Total ordering (requires PartialOrd + Eq)\n)]\nstruct Point { x: i32, y: i32 }\n```\n\n### When to Derive What\n| Trait | When to use |\n|-------|------------|\n| `Debug` | Almost always - enables println!(\"{:?}\", x) |\n| `Clone` | When you need to duplicate values |\n| `Copy` | Small, stack-only types (like i32, bool) |\n| `PartialEq` | When you need == comparisons |\n| `Hash` | When using as HashMap/HashSet key |\n| `Default` | When there's a sensible default |\n\n### Derive Requirements\n```rust\n// All fields must implement the trait\n#[derive(Clone)]\nstruct Container {\n    data: Vec<u8>,  // Vec implements Clone ✓\n    id: u32,        // u32 implements Clone ✓\n}\n```\n\n### Serde for Serialization\n```rust\n#[derive(Serialize, Deserialize)]\nstruct Config {\n    name: String,\n    count: u32,\n}\n```",
            "confidence": 0.5,
            "contexts": [
                "general"
            ]
        },
        {
            "id": "from-into-trait",
            "pattern": "impl\\s+From<|impl\\s+Into<|\\.into\\(\\)|\\.from\\(",
            "title": "From/Into Conversions",
            "rustTerm": "From and Into traits",
            "explanation": "From/Into provide type conversions. Implement From and you get Into for free. Use `.into()` for ergonomic conversions.",
            "example": "let s: String = \"hello\".into();\n// Same as: String::from(\"hello\")",
            "deepExplanation": "## From and Into Traits\n\n### The Relationship\n- Implement `From<T>` to get `Into<T>` automatically\n- Always implement `From`, never `Into` directly\n\n### Implementing From\n```rust\nstruct Meters(f64);\nstruct Feet(f64);\n\nimpl From<Feet> for Meters {\n    fn from(feet: Feet) -> Self {\n        Meters(feet.0 * 0.3048)\n    }\n}\n\n// Now both work:\nlet m = Meters::from(Feet(10.0));\nlet m: Meters = Feet(10.0).into();\n```\n\n### Common Uses\n```rust\n// String from &str\nlet s: String = \"hello\".into();\nlet s = String::from(\"hello\");\n\n// PathBuf from &str\nlet p: PathBuf = \"./file.txt\".into();\n\n// Vec from array\nlet v: Vec<i32> = [1, 2, 3].into();\n```\n\n### In Function Parameters\n```rust\n// Accept anything that converts to String\nfn greet(name: impl Into<String>) {\n    let name = name.into();\n    println!(\"Hello, {}\", name);\n}\n\ngreet(\"Alice\");           // &str\ngreet(String::from(\"Bob\")); // String\n```\n\n### TryFrom for Fallible Conversions\n```rust\nimpl TryFrom<i32> for PositiveInt {\n    type Error = &'static str;\n    \n    fn try_from(value: i32) -> Result<Self, Self::Error> {\n        if value > 0 {\n            Ok(PositiveInt(value))\n        } else {\n            Err(\"must be positive\")\n        }\n    }\n}\n```",
            "confidence": 0.6,
            "contexts": [
                "general"
            ]
        },
        {
            "id": "display-debug-trait",
            "pattern": "impl\\s+Display|impl\\s+Debug|fmt::Result",
            "title": "Display vs Debug",
            "rustTerm": "Display and Debug traits",
            "explanation": "Debug ({:?}) is for developers, Display ({}) is for users. Derive Debug, implement Display manually.",
            "example": "// Debug: #[derive(Debug)] or impl Debug\n// Display: impl Display (manual only)\nprintln!(\"{:?}\", val);  // Debug\nprintln!(\"{}\", val);    // Display",
            "deepExplanation": "## Display vs Debug\n\n### Debug - For Developers\n```rust\n#[derive(Debug)]\nstruct Point { x: i32, y: i32 }\n\nlet p = Point { x: 10, y: 20 };\nprintln!(\"{:?}\", p);   // Point { x: 10, y: 20 }\nprintln!(\"{:#?}\", p);  // Pretty-printed\n```\n\n### Display - For Users\n```rust\nuse std::fmt;\n\nimpl fmt::Display for Point {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(f, \"({}, {})\", self.x, self.y)\n    }\n}\n\nprintln!(\"{}\", p);  // (10, 20)\n```\n\n### When to Use Which\n| Format | Trait | Purpose |\n|--------|-------|--------|\n| `{}` | Display | User-facing output |\n| `{:?}` | Debug | Developer debugging |\n| `{:#?}` | Debug | Pretty-printed debug |\n\n### Display Enables .to_string()\n```rust\nimpl Display for Point { ... }\n\nlet s = p.to_string();  // \"(10, 20)\"\n```\n\n### Error Messages\n```rust\n// Errors should implement Display for user messages\nimpl Display for MyError {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(f, \"Operation failed: {}\", self.reason)\n    }\n}\n```",
            "confidence": 0.6,
            "contexts": [
                "general"
            ]
        },
        {
            "id": "default-trait",
            "pattern": "#\\[derive\\([^)]*Default|impl\\s+Default|Default::default",
            "title": "Default Trait",
            "rustTerm": "Default trait",
            "explanation": "Default provides a default value for a type. Use `..Default::default()` for partial struct initialization.",
            "example": "let config = Config {\n    name: \"custom\".into(),\n    ..Default::default()  // Fill rest with defaults\n};",
            "deepExplanation": "## Default Trait\n\nProvides a sensible default value.\n\n### Deriving Default\n```rust\n#[derive(Default)]\nstruct Config {\n    enabled: bool,     // defaults to false\n    count: u32,        // defaults to 0\n    name: String,      // defaults to \"\"\n}\n\nlet config = Config::default();\n```\n\n### Custom Default\n```rust\nimpl Default for Config {\n    fn default() -> Self {\n        Config {\n            enabled: true,\n            count: 10,\n            name: String::from(\"default\"),\n        }\n    }\n}\n```\n\n### Partial Initialization\n```rust\nlet config = Config {\n    name: \"custom\".into(),\n    ..Default::default()  // Rest from default\n};\n```\n\n### With Option\n```rust\nlet value = opt.unwrap_or_default();\n```\n\n### In Generic Code\n```rust\nfn get_or_default<T: Default>(opt: Option<T>) -> T {\n    opt.unwrap_or_default()\n}\n```\n\n### Builder Pattern Alternative\n```rust\nConfig::default()\n    .with_name(\"custom\")\n    .with_count(5)\n```",
            "confidence": 0.5,
            "contexts": [
                "general"
            ]
        },
        {
            "id": "dyn-trait",
            "pattern": "dyn\\s+\\w+|Box<dyn|&dyn",
            "title": "Dynamic Dispatch",
            "rustTerm": "dyn Trait",
            "explanation": "Use `dyn Trait` for runtime polymorphism (trait objects). Requires `Box`, `&`, or `Rc` because size is unknown.",
            "example": "fn process(handler: &dyn Handler) { ... }\nlet handlers: Vec<Box<dyn Handler>> = vec![];",
            "deepExplanation": "## Dynamic Dispatch with dyn\n\n### Static vs Dynamic Dispatch\n```rust\n// Static (monomorphization) - faster\nfn process<T: Handler>(h: T) { ... }\n\n// Dynamic (vtable lookup) - flexible\nfn process(h: &dyn Handler) { ... }\n```\n\n### Why Box/&/Rc?\n```rust\n// Won't compile - size unknown at compile time\nlet handler: dyn Handler = ...;  // Error!\n\n// These work - known size (pointer)\nlet handler: &dyn Handler = &concrete;\nlet handler: Box<dyn Handler> = Box::new(concrete);\nlet handler: Rc<dyn Handler> = Rc::new(concrete);\n```\n\n### Heterogeneous Collections\n```rust\ntrait Animal {\n    fn speak(&self);\n}\n\nlet animals: Vec<Box<dyn Animal>> = vec![\n    Box::new(Dog {}),\n    Box::new(Cat {}),\n    Box::new(Bird {}),\n];\n\nfor animal in &animals {\n    animal.speak();  // Runtime dispatch\n}\n```\n\n### Object Safety\nNot all traits can be made into trait objects:\n```rust\n// Object-safe (can use dyn)\ntrait Drawable {\n    fn draw(&self);\n}\n\n// NOT object-safe (can't use dyn)\ntrait Cloneable {\n    fn clone(&self) -> Self;  // Returns Self\n}\n```\n\n### When to Use\n- **dyn**: Different types at runtime, smaller binary\n- **impl/generics**: Known types, better performance",
            "confidence": 0.7,
            "contexts": [
                "general"
            ]
        },
        {
            "id": "impl-trait-return",
            "pattern": "->\\s*impl\\s+\\w+",
            "title": "impl Trait in Return",
            "rustTerm": "impl Trait",
            "explanation": "Return `impl Trait` when you want to hide the concrete type. The actual type is still known at compile time.",
            "example": "fn make_iter() -> impl Iterator<Item = i32> {\n    (0..10).filter(|x| x % 2 == 0)\n}",
            "deepExplanation": "## impl Trait in Return Position\n\nHide concrete type while keeping static dispatch.\n\n### The Problem\n```rust\n// Return type is complex and leaks implementation\nfn make_iter() -> std::iter::Filter<std::ops::Range<i32>, fn(&i32) -> bool> {\n    (0..10).filter(|x| x % 2 == 0)\n}\n```\n\n### The Solution\n```rust\nfn make_iter() -> impl Iterator<Item = i32> {\n    (0..10).filter(|x| x % 2 == 0)\n}\n```\n\n### Benefits\n- Clean API - users don't see implementation details\n- Static dispatch - no runtime cost\n- Can change implementation without breaking API\n\n### Closures\n```rust\n// Closures have unnameable types\nfn make_adder(n: i32) -> impl Fn(i32) -> i32 {\n    move |x| x + n\n}\n```\n\n### Limitations\n```rust\n// Can't return different types\nfn make_iter(flag: bool) -> impl Iterator<Item = i32> {\n    if flag {\n        vec![1, 2, 3].into_iter()  // Vec iterator\n    } else {\n        (0..3)  // Range iterator - ERROR!\n    }\n}\n\n// Use Box<dyn> for this\nfn make_iter(flag: bool) -> Box<dyn Iterator<Item = i32>> {\n    if flag {\n        Box::new(vec![1, 2, 3].into_iter())\n    } else {\n        Box::new(0..3)\n    }\n}\n```",
            "confidence": 0.7,
            "contexts": [
                "general"
            ]
        },
        {
            "id": "associated-types",
            "pattern": "type\\s+\\w+\\s*=|type\\s+\\w+\\s*;",
            "title": "Associated Types",
            "rustTerm": "associated types",
            "explanation": "Associated types define a type placeholder in a trait. Cleaner than generics when there's one logical type.",
            "example": "trait Iterator {\n    type Item;  // Associated type\n    fn next(&mut self) -> Option<Self::Item>;\n}",
            "deepExplanation": "## Associated Types\n\n### In Trait Definition\n```rust\ntrait Iterator {\n    type Item;  // Associated type\n    \n    fn next(&mut self) -> Option<Self::Item>;\n}\n```\n\n### In Implementation\n```rust\nimpl Iterator for Counter {\n    type Item = u32;  // Concrete type\n    \n    fn next(&mut self) -> Option<Self::Item> {\n        // ...\n    }\n}\n```\n\n### vs Generics\n```rust\n// With generics - multiple impls possible\ntrait Container<T> {\n    fn get(&self) -> T;\n}\n\nimpl Container<i32> for MyType { ... }\nimpl Container<String> for MyType { ... }\n\n// With associated types - one impl per type\ntrait Container {\n    type Item;\n    fn get(&self) -> Self::Item;\n}\n\nimpl Container for MyType {\n    type Item = i32;  // Only one choice\n    fn get(&self) -> i32 { ... }\n}\n```\n\n### When to Use Which\n| Use | When |\n|-----|------|\n| Associated type | One logical output type per impl |\n| Generic | Multiple implementations make sense |\n\n### With Bounds\n```rust\ntrait Graph {\n    type Node: Clone + Debug;\n    type Edge: Clone;\n    \n    fn nodes(&self) -> Vec<Self::Node>;\n}\n```",
            "confidence": 0.5,
            "contexts": [
                "general"
            ]
        },
        {
            "id": "where-clause",
            "pattern": "where\\s+\\w+\\s*:",
            "title": "Where Clauses",
            "rustTerm": "where clause",
            "explanation": "Use `where` clauses for complex trait bounds. Cleaner than inline bounds for multiple constraints.",
            "example": "fn process<T, U>(t: T, u: U) -> i32\nwhere\n    T: Clone + Debug,\n    U: Into<String>,\n{ ... }",
            "deepExplanation": "## Where Clauses\n\nCleaner syntax for complex trait bounds.\n\n### Basic Usage\n```rust\n// Inline bounds (cluttered)\nfn process<T: Clone + Debug + PartialEq, U: Into<String> + Default>(t: T, u: U) { }\n\n// Where clause (clearer)\nfn process<T, U>(t: T, u: U)\nwhere\n    T: Clone + Debug + PartialEq,\n    U: Into<String> + Default,\n{\n    // ...\n}\n```\n\n### When Required\n```rust\n// Bounds on associated types\nfn process<I>(iter: I)\nwhere\n    I: Iterator,\n    I::Item: Debug,  // Can't do this inline\n{\n    for item in iter {\n        println!(\"{:?}\", item);\n    }\n}\n```\n\n### On Impl Blocks\n```rust\nimpl<T> MyStruct<T>\nwhere\n    T: Clone + Debug,\n{\n    fn new(value: T) -> Self {\n        // ...\n    }\n}\n```\n\n### Multiple Where Clauses\n```rust\nfn complex<A, B, C>(a: A, b: B, c: C)\nwhere\n    A: Clone,\n    B: Clone + Into<A>,\n    C: Default + From<B>,\n{\n    // ...\n}\n```\n\n### Style Guideline\n- 1-2 simple bounds: inline\n- 3+ bounds or complex bounds: where clause",
            "confidence": 0.5,
            "contexts": [
                "general"
            ]
        },
        {
            "id": "phantom-data",
            "pattern": "PhantomData|std::marker::PhantomData",
            "title": "PhantomData",
            "rustTerm": "PhantomData<T>",
            "explanation": "PhantomData tells the compiler your type logically owns a T, even if it doesn't store one directly.",
            "example": "struct Iter<'a, T> {\n    ptr: *const T,\n    _marker: PhantomData<&'a T>,\n}",
            "deepExplanation": "## PhantomData\n\nMarker for type-level information without runtime cost.\n\n### Why Needed\n```rust\nstruct Iter<T> {\n    ptr: *const T,  // Raw pointer, no ownership\n}\n// Compiler doesn't know Iter relates to T's lifetime!\n```\n\n### The Fix\n```rust\nuse std::marker::PhantomData;\n\nstruct Iter<'a, T> {\n    ptr: *const T,\n    _marker: PhantomData<&'a T>,  // \"I act like I have &'a T\"\n}\n```\n\n### Common Uses\n\n**Lifetime markers:**\n```rust\nstruct Parser<'a> {\n    pos: usize,\n    _lifetime: PhantomData<&'a str>,\n}\n```\n\n**Type markers:**\n```rust\nstruct TypedId<T> {\n    id: u64,\n    _type: PhantomData<T>,  // Id \"of\" T\n}\n\nlet user_id: TypedId<User> = ...;\nlet post_id: TypedId<Post> = ...;\n// Can't mix them up!\n```\n\n**Variance control:**\n```rust\nstruct Covariant<T>(PhantomData<T>);       // Covariant\nstruct Contravariant<T>(PhantomData<fn(T)>); // Contravariant\nstruct Invariant<T>(PhantomData<fn(T) -> T>); // Invariant\n```\n\n### Zero-Sized\n```rust\nassert_eq!(std::mem::size_of::<PhantomData<String>>(), 0);\n```",
            "confidence": 0.8,
            "contexts": [
                "general"
            ]
        }
    ]
}